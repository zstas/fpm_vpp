// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: fpm/fpm.proto

#ifndef PROTOBUF_INCLUDED_fpm_2ffpm_2eproto
#define PROTOBUF_INCLUDED_fpm_2ffpm_2eproto

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3006001
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3006001 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/inlined_string_field.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
#include <google/protobuf/unknown_field_set.h>
#include "qpb/qpb.pb.h"
// @@protoc_insertion_point(includes)
#define PROTOBUF_INTERNAL_EXPORT_protobuf_fpm_2ffpm_2eproto 

namespace protobuf_fpm_2ffpm_2eproto {
// Internal implementation detail -- do not use these members.
struct TableStruct {
  static const ::google::protobuf::internal::ParseTableField entries[];
  static const ::google::protobuf::internal::AuxillaryParseTableField aux[];
  static const ::google::protobuf::internal::ParseTable schema[5];
  static const ::google::protobuf::internal::FieldMetadata field_metadata[];
  static const ::google::protobuf::internal::SerializationTable serialization_table[];
  static const ::google::protobuf::uint32 offsets[];
};
void AddDescriptors();
}  // namespace protobuf_fpm_2ffpm_2eproto
namespace fpm {
class AddRoute;
class AddRouteDefaultTypeInternal;
extern AddRouteDefaultTypeInternal _AddRoute_default_instance_;
class DeleteRoute;
class DeleteRouteDefaultTypeInternal;
extern DeleteRouteDefaultTypeInternal _DeleteRoute_default_instance_;
class Message;
class MessageDefaultTypeInternal;
extern MessageDefaultTypeInternal _Message_default_instance_;
class Nexthop;
class NexthopDefaultTypeInternal;
extern NexthopDefaultTypeInternal _Nexthop_default_instance_;
class RouteKey;
class RouteKeyDefaultTypeInternal;
extern RouteKeyDefaultTypeInternal _RouteKey_default_instance_;
}  // namespace fpm
namespace google {
namespace protobuf {
template<> ::fpm::AddRoute* Arena::CreateMaybeMessage<::fpm::AddRoute>(Arena*);
template<> ::fpm::DeleteRoute* Arena::CreateMaybeMessage<::fpm::DeleteRoute>(Arena*);
template<> ::fpm::Message* Arena::CreateMaybeMessage<::fpm::Message>(Arena*);
template<> ::fpm::Nexthop* Arena::CreateMaybeMessage<::fpm::Nexthop>(Arena*);
template<> ::fpm::RouteKey* Arena::CreateMaybeMessage<::fpm::RouteKey>(Arena*);
}  // namespace protobuf
}  // namespace google
namespace fpm {

enum Message_Type {
  Message_Type_UNKNOWN_MSG = 0,
  Message_Type_ADD_ROUTE = 1,
  Message_Type_DELETE_ROUTE = 2
};
bool Message_Type_IsValid(int value);
const Message_Type Message_Type_Type_MIN = Message_Type_UNKNOWN_MSG;
const Message_Type Message_Type_Type_MAX = Message_Type_DELETE_ROUTE;
const int Message_Type_Type_ARRAYSIZE = Message_Type_Type_MAX + 1;

const ::google::protobuf::EnumDescriptor* Message_Type_descriptor();
inline const ::std::string& Message_Type_Name(Message_Type value) {
  return ::google::protobuf::internal::NameOfEnum(
    Message_Type_descriptor(), value);
}
inline bool Message_Type_Parse(
    const ::std::string& name, Message_Type* value) {
  return ::google::protobuf::internal::ParseNamedEnum<Message_Type>(
    Message_Type_descriptor(), name, value);
}
enum RouteType {
  UNKNOWN = 0,
  NORMAL = 1,
  UNREACHABLE = 2,
  BLACKHOLE = 3
};
bool RouteType_IsValid(int value);
const RouteType RouteType_MIN = UNKNOWN;
const RouteType RouteType_MAX = BLACKHOLE;
const int RouteType_ARRAYSIZE = RouteType_MAX + 1;

const ::google::protobuf::EnumDescriptor* RouteType_descriptor();
inline const ::std::string& RouteType_Name(RouteType value) {
  return ::google::protobuf::internal::NameOfEnum(
    RouteType_descriptor(), value);
}
inline bool RouteType_Parse(
    const ::std::string& name, RouteType* value) {
  return ::google::protobuf::internal::ParseNamedEnum<RouteType>(
    RouteType_descriptor(), name, value);
}
// ===================================================================

class Nexthop : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fpm.Nexthop) */ {
 public:
  Nexthop();
  virtual ~Nexthop();

  Nexthop(const Nexthop& from);

  inline Nexthop& operator=(const Nexthop& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Nexthop(Nexthop&& from) noexcept
    : Nexthop() {
    *this = ::std::move(from);
  }

  inline Nexthop& operator=(Nexthop&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Nexthop& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Nexthop* internal_default_instance() {
    return reinterpret_cast<const Nexthop*>(
               &_Nexthop_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    0;

  void Swap(Nexthop* other);
  friend void swap(Nexthop& a, Nexthop& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Nexthop* New() const final {
    return CreateMaybeMessage<Nexthop>(NULL);
  }

  Nexthop* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Nexthop>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Nexthop& from);
  void MergeFrom(const Nexthop& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Nexthop* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qpb.IfIdentifier if_id = 2;
  bool has_if_id() const;
  void clear_if_id();
  static const int kIfIdFieldNumber = 2;
  private:
  const ::qpb::IfIdentifier& _internal_if_id() const;
  public:
  const ::qpb::IfIdentifier& if_id() const;
  ::qpb::IfIdentifier* release_if_id();
  ::qpb::IfIdentifier* mutable_if_id();
  void set_allocated_if_id(::qpb::IfIdentifier* if_id);

  // optional .qpb.L3Address address = 3;
  bool has_address() const;
  void clear_address();
  static const int kAddressFieldNumber = 3;
  private:
  const ::qpb::L3Address& _internal_address() const;
  public:
  const ::qpb::L3Address& address() const;
  ::qpb::L3Address* release_address();
  ::qpb::L3Address* mutable_address();
  void set_allocated_address(::qpb::L3Address* address);

  // @@protoc_insertion_point(class_scope:fpm.Nexthop)
 private:
  void set_has_if_id();
  void clear_has_if_id();
  void set_has_address();
  void clear_has_address();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::qpb::IfIdentifier* if_id_;
  ::qpb::L3Address* address_;
  friend struct ::protobuf_fpm_2ffpm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class RouteKey : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fpm.RouteKey) */ {
 public:
  RouteKey();
  virtual ~RouteKey();

  RouteKey(const RouteKey& from);

  inline RouteKey& operator=(const RouteKey& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  RouteKey(RouteKey&& from) noexcept
    : RouteKey() {
    *this = ::std::move(from);
  }

  inline RouteKey& operator=(RouteKey&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const RouteKey& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const RouteKey* internal_default_instance() {
    return reinterpret_cast<const RouteKey*>(
               &_RouteKey_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    1;

  void Swap(RouteKey* other);
  friend void swap(RouteKey& a, RouteKey& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline RouteKey* New() const final {
    return CreateMaybeMessage<RouteKey>(NULL);
  }

  RouteKey* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<RouteKey>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const RouteKey& from);
  void MergeFrom(const RouteKey& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(RouteKey* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .qpb.L3Prefix prefix = 1;
  bool has_prefix() const;
  void clear_prefix();
  static const int kPrefixFieldNumber = 1;
  private:
  const ::qpb::L3Prefix& _internal_prefix() const;
  public:
  const ::qpb::L3Prefix& prefix() const;
  ::qpb::L3Prefix* release_prefix();
  ::qpb::L3Prefix* mutable_prefix();
  void set_allocated_prefix(::qpb::L3Prefix* prefix);

  // @@protoc_insertion_point(class_scope:fpm.RouteKey)
 private:
  void set_has_prefix();
  void clear_has_prefix();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::qpb::L3Prefix* prefix_;
  friend struct ::protobuf_fpm_2ffpm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class DeleteRoute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fpm.DeleteRoute) */ {
 public:
  DeleteRoute();
  virtual ~DeleteRoute();

  DeleteRoute(const DeleteRoute& from);

  inline DeleteRoute& operator=(const DeleteRoute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  DeleteRoute(DeleteRoute&& from) noexcept
    : DeleteRoute() {
    *this = ::std::move(from);
  }

  inline DeleteRoute& operator=(DeleteRoute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const DeleteRoute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const DeleteRoute* internal_default_instance() {
    return reinterpret_cast<const DeleteRoute*>(
               &_DeleteRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    2;

  void Swap(DeleteRoute* other);
  friend void swap(DeleteRoute& a, DeleteRoute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline DeleteRoute* New() const final {
    return CreateMaybeMessage<DeleteRoute>(NULL);
  }

  DeleteRoute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<DeleteRoute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const DeleteRoute& from);
  void MergeFrom(const DeleteRoute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(DeleteRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // required .fpm.RouteKey key = 4;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  private:
  const ::fpm::RouteKey& _internal_key() const;
  public:
  const ::fpm::RouteKey& key() const;
  ::fpm::RouteKey* release_key();
  ::fpm::RouteKey* mutable_key();
  void set_allocated_key(::fpm::RouteKey* key);

  // required uint32 vrf_id = 1;
  bool has_vrf_id() const;
  void clear_vrf_id();
  static const int kVrfIdFieldNumber = 1;
  ::google::protobuf::uint32 vrf_id() const;
  void set_vrf_id(::google::protobuf::uint32 value);

  // required .qpb.AddressFamily address_family = 2;
  bool has_address_family() const;
  void clear_address_family();
  static const int kAddressFamilyFieldNumber = 2;
  ::qpb::AddressFamily address_family() const;
  void set_address_family(::qpb::AddressFamily value);

  // required .qpb.SubAddressFamily sub_address_family = 3;
  bool has_sub_address_family() const;
  void clear_sub_address_family();
  static const int kSubAddressFamilyFieldNumber = 3;
  ::qpb::SubAddressFamily sub_address_family() const;
  void set_sub_address_family(::qpb::SubAddressFamily value);

  // @@protoc_insertion_point(class_scope:fpm.DeleteRoute)
 private:
  void set_has_vrf_id();
  void clear_has_vrf_id();
  void set_has_address_family();
  void clear_has_address_family();
  void set_has_sub_address_family();
  void clear_has_sub_address_family();
  void set_has_key();
  void clear_has_key();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::fpm::RouteKey* key_;
  ::google::protobuf::uint32 vrf_id_;
  int address_family_;
  int sub_address_family_;
  friend struct ::protobuf_fpm_2ffpm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class AddRoute : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fpm.AddRoute) */ {
 public:
  AddRoute();
  virtual ~AddRoute();

  AddRoute(const AddRoute& from);

  inline AddRoute& operator=(const AddRoute& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  AddRoute(AddRoute&& from) noexcept
    : AddRoute() {
    *this = ::std::move(from);
  }

  inline AddRoute& operator=(AddRoute&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const AddRoute& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const AddRoute* internal_default_instance() {
    return reinterpret_cast<const AddRoute*>(
               &_AddRoute_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    3;

  void Swap(AddRoute* other);
  friend void swap(AddRoute& a, AddRoute& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline AddRoute* New() const final {
    return CreateMaybeMessage<AddRoute>(NULL);
  }

  AddRoute* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<AddRoute>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const AddRoute& from);
  void MergeFrom(const AddRoute& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(AddRoute* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .fpm.Nexthop nexthops = 9;
  int nexthops_size() const;
  void clear_nexthops();
  static const int kNexthopsFieldNumber = 9;
  ::fpm::Nexthop* mutable_nexthops(int index);
  ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >*
      mutable_nexthops();
  const ::fpm::Nexthop& nexthops(int index) const;
  ::fpm::Nexthop* add_nexthops();
  const ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >&
      nexthops() const;

  // required .fpm.RouteKey key = 4;
  bool has_key() const;
  void clear_key();
  static const int kKeyFieldNumber = 4;
  private:
  const ::fpm::RouteKey& _internal_key() const;
  public:
  const ::fpm::RouteKey& key() const;
  ::fpm::RouteKey* release_key();
  ::fpm::RouteKey* mutable_key();
  void set_allocated_key(::fpm::RouteKey* key);

  // required uint32 vrf_id = 1;
  bool has_vrf_id() const;
  void clear_vrf_id();
  static const int kVrfIdFieldNumber = 1;
  ::google::protobuf::uint32 vrf_id() const;
  void set_vrf_id(::google::protobuf::uint32 value);

  // required .qpb.AddressFamily address_family = 2;
  bool has_address_family() const;
  void clear_address_family();
  static const int kAddressFamilyFieldNumber = 2;
  ::qpb::AddressFamily address_family() const;
  void set_address_family(::qpb::AddressFamily value);

  // required .qpb.SubAddressFamily sub_address_family = 3;
  bool has_sub_address_family() const;
  void clear_sub_address_family();
  static const int kSubAddressFamilyFieldNumber = 3;
  ::qpb::SubAddressFamily sub_address_family() const;
  void set_sub_address_family(::qpb::SubAddressFamily value);

  // optional .fpm.RouteType route_type = 5;
  bool has_route_type() const;
  void clear_route_type();
  static const int kRouteTypeFieldNumber = 5;
  ::fpm::RouteType route_type() const;
  void set_route_type(::fpm::RouteType value);

  // required .qpb.Protocol protocol = 6;
  bool has_protocol() const;
  void clear_protocol();
  static const int kProtocolFieldNumber = 6;
  ::qpb::Protocol protocol() const;
  void set_protocol(::qpb::Protocol value);

  // required int32 metric = 8;
  bool has_metric() const;
  void clear_metric();
  static const int kMetricFieldNumber = 8;
  ::google::protobuf::int32 metric() const;
  void set_metric(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:fpm.AddRoute)
 private:
  void set_has_vrf_id();
  void clear_has_vrf_id();
  void set_has_address_family();
  void clear_has_address_family();
  void set_has_sub_address_family();
  void clear_has_sub_address_family();
  void set_has_key();
  void clear_has_key();
  void set_has_route_type();
  void clear_has_route_type();
  void set_has_protocol();
  void clear_has_protocol();
  void set_has_metric();
  void clear_has_metric();

  // helper for ByteSizeLong()
  size_t RequiredFieldsByteSizeFallback() const;

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop > nexthops_;
  ::fpm::RouteKey* key_;
  ::google::protobuf::uint32 vrf_id_;
  int address_family_;
  int sub_address_family_;
  int route_type_;
  int protocol_;
  ::google::protobuf::int32 metric_;
  friend struct ::protobuf_fpm_2ffpm_2eproto::TableStruct;
};
// -------------------------------------------------------------------

class Message : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:fpm.Message) */ {
 public:
  Message();
  virtual ~Message();

  Message(const Message& from);

  inline Message& operator=(const Message& from) {
    CopyFrom(from);
    return *this;
  }
  #if LANG_CXX11
  Message(Message&& from) noexcept
    : Message() {
    *this = ::std::move(from);
  }

  inline Message& operator=(Message&& from) noexcept {
    if (GetArenaNoVirtual() == from.GetArenaNoVirtual()) {
      if (this != &from) InternalSwap(&from);
    } else {
      CopyFrom(from);
    }
    return *this;
  }
  #endif
  inline const ::google::protobuf::UnknownFieldSet& unknown_fields() const {
    return _internal_metadata_.unknown_fields();
  }
  inline ::google::protobuf::UnknownFieldSet* mutable_unknown_fields() {
    return _internal_metadata_.mutable_unknown_fields();
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Message& default_instance();

  static void InitAsDefaultInstance();  // FOR INTERNAL USE ONLY
  static inline const Message* internal_default_instance() {
    return reinterpret_cast<const Message*>(
               &_Message_default_instance_);
  }
  static constexpr int kIndexInFileMessages =
    4;

  void Swap(Message* other);
  friend void swap(Message& a, Message& b) {
    a.Swap(&b);
  }

  // implements Message ----------------------------------------------

  inline Message* New() const final {
    return CreateMaybeMessage<Message>(NULL);
  }

  Message* New(::google::protobuf::Arena* arena) const final {
    return CreateMaybeMessage<Message>(arena);
  }
  void CopyFrom(const ::google::protobuf::Message& from) final;
  void MergeFrom(const ::google::protobuf::Message& from) final;
  void CopyFrom(const Message& from);
  void MergeFrom(const Message& from);
  void Clear() final;
  bool IsInitialized() const final;

  size_t ByteSizeLong() const final;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input) final;
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const final;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* target) const final;
  int GetCachedSize() const final { return _cached_size_.Get(); }

  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const final;
  void InternalSwap(Message* other);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return NULL;
  }
  inline void* MaybeArenaPtr() const {
    return NULL;
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const final;

  // nested types ----------------------------------------------------

  typedef Message_Type Type;
  static const Type UNKNOWN_MSG =
    Message_Type_UNKNOWN_MSG;
  static const Type ADD_ROUTE =
    Message_Type_ADD_ROUTE;
  static const Type DELETE_ROUTE =
    Message_Type_DELETE_ROUTE;
  static inline bool Type_IsValid(int value) {
    return Message_Type_IsValid(value);
  }
  static const Type Type_MIN =
    Message_Type_Type_MIN;
  static const Type Type_MAX =
    Message_Type_Type_MAX;
  static const int Type_ARRAYSIZE =
    Message_Type_Type_ARRAYSIZE;
  static inline const ::google::protobuf::EnumDescriptor*
  Type_descriptor() {
    return Message_Type_descriptor();
  }
  static inline const ::std::string& Type_Name(Type value) {
    return Message_Type_Name(value);
  }
  static inline bool Type_Parse(const ::std::string& name,
      Type* value) {
    return Message_Type_Parse(name, value);
  }

  // accessors -------------------------------------------------------

  // optional .fpm.AddRoute add_route = 2;
  bool has_add_route() const;
  void clear_add_route();
  static const int kAddRouteFieldNumber = 2;
  private:
  const ::fpm::AddRoute& _internal_add_route() const;
  public:
  const ::fpm::AddRoute& add_route() const;
  ::fpm::AddRoute* release_add_route();
  ::fpm::AddRoute* mutable_add_route();
  void set_allocated_add_route(::fpm::AddRoute* add_route);

  // optional .fpm.DeleteRoute delete_route = 3;
  bool has_delete_route() const;
  void clear_delete_route();
  static const int kDeleteRouteFieldNumber = 3;
  private:
  const ::fpm::DeleteRoute& _internal_delete_route() const;
  public:
  const ::fpm::DeleteRoute& delete_route() const;
  ::fpm::DeleteRoute* release_delete_route();
  ::fpm::DeleteRoute* mutable_delete_route();
  void set_allocated_delete_route(::fpm::DeleteRoute* delete_route);

  // optional .fpm.Message.Type type = 1;
  bool has_type() const;
  void clear_type();
  static const int kTypeFieldNumber = 1;
  ::fpm::Message_Type type() const;
  void set_type(::fpm::Message_Type value);

  // @@protoc_insertion_point(class_scope:fpm.Message)
 private:
  void set_has_type();
  void clear_has_type();
  void set_has_add_route();
  void clear_has_add_route();
  void set_has_delete_route();
  void clear_has_delete_route();

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::HasBits<1> _has_bits_;
  mutable ::google::protobuf::internal::CachedSize _cached_size_;
  ::fpm::AddRoute* add_route_;
  ::fpm::DeleteRoute* delete_route_;
  int type_;
  friend struct ::protobuf_fpm_2ffpm_2eproto::TableStruct;
};
// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
// Nexthop

// optional .qpb.IfIdentifier if_id = 2;
inline bool Nexthop::has_if_id() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Nexthop::set_has_if_id() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Nexthop::clear_has_if_id() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::qpb::IfIdentifier& Nexthop::_internal_if_id() const {
  return *if_id_;
}
inline const ::qpb::IfIdentifier& Nexthop::if_id() const {
  const ::qpb::IfIdentifier* p = if_id_;
  // @@protoc_insertion_point(field_get:fpm.Nexthop.if_id)
  return p != NULL ? *p : *reinterpret_cast<const ::qpb::IfIdentifier*>(
      &::qpb::_IfIdentifier_default_instance_);
}
inline ::qpb::IfIdentifier* Nexthop::release_if_id() {
  // @@protoc_insertion_point(field_release:fpm.Nexthop.if_id)
  clear_has_if_id();
  ::qpb::IfIdentifier* temp = if_id_;
  if_id_ = NULL;
  return temp;
}
inline ::qpb::IfIdentifier* Nexthop::mutable_if_id() {
  set_has_if_id();
  if (if_id_ == NULL) {
    auto* p = CreateMaybeMessage<::qpb::IfIdentifier>(GetArenaNoVirtual());
    if_id_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Nexthop.if_id)
  return if_id_;
}
inline void Nexthop::set_allocated_if_id(::qpb::IfIdentifier* if_id) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(if_id_);
  }
  if (if_id) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      if_id = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, if_id, submessage_arena);
    }
    set_has_if_id();
  } else {
    clear_has_if_id();
  }
  if_id_ = if_id;
  // @@protoc_insertion_point(field_set_allocated:fpm.Nexthop.if_id)
}

// optional .qpb.L3Address address = 3;
inline bool Nexthop::has_address() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Nexthop::set_has_address() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Nexthop::clear_has_address() {
  _has_bits_[0] &= ~0x00000002u;
}
inline const ::qpb::L3Address& Nexthop::_internal_address() const {
  return *address_;
}
inline const ::qpb::L3Address& Nexthop::address() const {
  const ::qpb::L3Address* p = address_;
  // @@protoc_insertion_point(field_get:fpm.Nexthop.address)
  return p != NULL ? *p : *reinterpret_cast<const ::qpb::L3Address*>(
      &::qpb::_L3Address_default_instance_);
}
inline ::qpb::L3Address* Nexthop::release_address() {
  // @@protoc_insertion_point(field_release:fpm.Nexthop.address)
  clear_has_address();
  ::qpb::L3Address* temp = address_;
  address_ = NULL;
  return temp;
}
inline ::qpb::L3Address* Nexthop::mutable_address() {
  set_has_address();
  if (address_ == NULL) {
    auto* p = CreateMaybeMessage<::qpb::L3Address>(GetArenaNoVirtual());
    address_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Nexthop.address)
  return address_;
}
inline void Nexthop::set_allocated_address(::qpb::L3Address* address) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(address_);
  }
  if (address) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      address = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, address, submessage_arena);
    }
    set_has_address();
  } else {
    clear_has_address();
  }
  address_ = address;
  // @@protoc_insertion_point(field_set_allocated:fpm.Nexthop.address)
}

// -------------------------------------------------------------------

// RouteKey

// optional .qpb.L3Prefix prefix = 1;
inline bool RouteKey::has_prefix() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void RouteKey::set_has_prefix() {
  _has_bits_[0] |= 0x00000001u;
}
inline void RouteKey::clear_has_prefix() {
  _has_bits_[0] &= ~0x00000001u;
}
inline const ::qpb::L3Prefix& RouteKey::_internal_prefix() const {
  return *prefix_;
}
inline const ::qpb::L3Prefix& RouteKey::prefix() const {
  const ::qpb::L3Prefix* p = prefix_;
  // @@protoc_insertion_point(field_get:fpm.RouteKey.prefix)
  return p != NULL ? *p : *reinterpret_cast<const ::qpb::L3Prefix*>(
      &::qpb::_L3Prefix_default_instance_);
}
inline ::qpb::L3Prefix* RouteKey::release_prefix() {
  // @@protoc_insertion_point(field_release:fpm.RouteKey.prefix)
  clear_has_prefix();
  ::qpb::L3Prefix* temp = prefix_;
  prefix_ = NULL;
  return temp;
}
inline ::qpb::L3Prefix* RouteKey::mutable_prefix() {
  set_has_prefix();
  if (prefix_ == NULL) {
    auto* p = CreateMaybeMessage<::qpb::L3Prefix>(GetArenaNoVirtual());
    prefix_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fpm.RouteKey.prefix)
  return prefix_;
}
inline void RouteKey::set_allocated_prefix(::qpb::L3Prefix* prefix) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete reinterpret_cast< ::google::protobuf::MessageLite*>(prefix_);
  }
  if (prefix) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      prefix = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, prefix, submessage_arena);
    }
    set_has_prefix();
  } else {
    clear_has_prefix();
  }
  prefix_ = prefix;
  // @@protoc_insertion_point(field_set_allocated:fpm.RouteKey.prefix)
}

// -------------------------------------------------------------------

// DeleteRoute

// required uint32 vrf_id = 1;
inline bool DeleteRoute::has_vrf_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void DeleteRoute::set_has_vrf_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void DeleteRoute::clear_has_vrf_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void DeleteRoute::clear_vrf_id() {
  vrf_id_ = 0u;
  clear_has_vrf_id();
}
inline ::google::protobuf::uint32 DeleteRoute::vrf_id() const {
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.vrf_id)
  return vrf_id_;
}
inline void DeleteRoute::set_vrf_id(::google::protobuf::uint32 value) {
  set_has_vrf_id();
  vrf_id_ = value;
  // @@protoc_insertion_point(field_set:fpm.DeleteRoute.vrf_id)
}

// required .qpb.AddressFamily address_family = 2;
inline bool DeleteRoute::has_address_family() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void DeleteRoute::set_has_address_family() {
  _has_bits_[0] |= 0x00000004u;
}
inline void DeleteRoute::clear_has_address_family() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void DeleteRoute::clear_address_family() {
  address_family_ = 0;
  clear_has_address_family();
}
inline ::qpb::AddressFamily DeleteRoute::address_family() const {
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.address_family)
  return static_cast< ::qpb::AddressFamily >(address_family_);
}
inline void DeleteRoute::set_address_family(::qpb::AddressFamily value) {
  assert(::qpb::AddressFamily_IsValid(value));
  set_has_address_family();
  address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.DeleteRoute.address_family)
}

// required .qpb.SubAddressFamily sub_address_family = 3;
inline bool DeleteRoute::has_sub_address_family() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void DeleteRoute::set_has_sub_address_family() {
  _has_bits_[0] |= 0x00000008u;
}
inline void DeleteRoute::clear_has_sub_address_family() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void DeleteRoute::clear_sub_address_family() {
  sub_address_family_ = 0;
  clear_has_sub_address_family();
}
inline ::qpb::SubAddressFamily DeleteRoute::sub_address_family() const {
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.sub_address_family)
  return static_cast< ::qpb::SubAddressFamily >(sub_address_family_);
}
inline void DeleteRoute::set_sub_address_family(::qpb::SubAddressFamily value) {
  assert(::qpb::SubAddressFamily_IsValid(value));
  set_has_sub_address_family();
  sub_address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.DeleteRoute.sub_address_family)
}

// required .fpm.RouteKey key = 4;
inline bool DeleteRoute::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void DeleteRoute::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void DeleteRoute::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void DeleteRoute::clear_key() {
  if (key_ != NULL) key_->Clear();
  clear_has_key();
}
inline const ::fpm::RouteKey& DeleteRoute::_internal_key() const {
  return *key_;
}
inline const ::fpm::RouteKey& DeleteRoute::key() const {
  const ::fpm::RouteKey* p = key_;
  // @@protoc_insertion_point(field_get:fpm.DeleteRoute.key)
  return p != NULL ? *p : *reinterpret_cast<const ::fpm::RouteKey*>(
      &::fpm::_RouteKey_default_instance_);
}
inline ::fpm::RouteKey* DeleteRoute::release_key() {
  // @@protoc_insertion_point(field_release:fpm.DeleteRoute.key)
  clear_has_key();
  ::fpm::RouteKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::fpm::RouteKey* DeleteRoute::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::fpm::RouteKey>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fpm.DeleteRoute.key)
  return key_;
}
inline void DeleteRoute::set_allocated_key(::fpm::RouteKey* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    set_has_key();
  } else {
    clear_has_key();
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:fpm.DeleteRoute.key)
}

// -------------------------------------------------------------------

// AddRoute

// required uint32 vrf_id = 1;
inline bool AddRoute::has_vrf_id() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void AddRoute::set_has_vrf_id() {
  _has_bits_[0] |= 0x00000002u;
}
inline void AddRoute::clear_has_vrf_id() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void AddRoute::clear_vrf_id() {
  vrf_id_ = 0u;
  clear_has_vrf_id();
}
inline ::google::protobuf::uint32 AddRoute::vrf_id() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.vrf_id)
  return vrf_id_;
}
inline void AddRoute::set_vrf_id(::google::protobuf::uint32 value) {
  set_has_vrf_id();
  vrf_id_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.vrf_id)
}

// required .qpb.AddressFamily address_family = 2;
inline bool AddRoute::has_address_family() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void AddRoute::set_has_address_family() {
  _has_bits_[0] |= 0x00000004u;
}
inline void AddRoute::clear_has_address_family() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void AddRoute::clear_address_family() {
  address_family_ = 0;
  clear_has_address_family();
}
inline ::qpb::AddressFamily AddRoute::address_family() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.address_family)
  return static_cast< ::qpb::AddressFamily >(address_family_);
}
inline void AddRoute::set_address_family(::qpb::AddressFamily value) {
  assert(::qpb::AddressFamily_IsValid(value));
  set_has_address_family();
  address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.address_family)
}

// required .qpb.SubAddressFamily sub_address_family = 3;
inline bool AddRoute::has_sub_address_family() const {
  return (_has_bits_[0] & 0x00000008u) != 0;
}
inline void AddRoute::set_has_sub_address_family() {
  _has_bits_[0] |= 0x00000008u;
}
inline void AddRoute::clear_has_sub_address_family() {
  _has_bits_[0] &= ~0x00000008u;
}
inline void AddRoute::clear_sub_address_family() {
  sub_address_family_ = 0;
  clear_has_sub_address_family();
}
inline ::qpb::SubAddressFamily AddRoute::sub_address_family() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.sub_address_family)
  return static_cast< ::qpb::SubAddressFamily >(sub_address_family_);
}
inline void AddRoute::set_sub_address_family(::qpb::SubAddressFamily value) {
  assert(::qpb::SubAddressFamily_IsValid(value));
  set_has_sub_address_family();
  sub_address_family_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.sub_address_family)
}

// required .fpm.RouteKey key = 4;
inline bool AddRoute::has_key() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void AddRoute::set_has_key() {
  _has_bits_[0] |= 0x00000001u;
}
inline void AddRoute::clear_has_key() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void AddRoute::clear_key() {
  if (key_ != NULL) key_->Clear();
  clear_has_key();
}
inline const ::fpm::RouteKey& AddRoute::_internal_key() const {
  return *key_;
}
inline const ::fpm::RouteKey& AddRoute::key() const {
  const ::fpm::RouteKey* p = key_;
  // @@protoc_insertion_point(field_get:fpm.AddRoute.key)
  return p != NULL ? *p : *reinterpret_cast<const ::fpm::RouteKey*>(
      &::fpm::_RouteKey_default_instance_);
}
inline ::fpm::RouteKey* AddRoute::release_key() {
  // @@protoc_insertion_point(field_release:fpm.AddRoute.key)
  clear_has_key();
  ::fpm::RouteKey* temp = key_;
  key_ = NULL;
  return temp;
}
inline ::fpm::RouteKey* AddRoute::mutable_key() {
  set_has_key();
  if (key_ == NULL) {
    auto* p = CreateMaybeMessage<::fpm::RouteKey>(GetArenaNoVirtual());
    key_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fpm.AddRoute.key)
  return key_;
}
inline void AddRoute::set_allocated_key(::fpm::RouteKey* key) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete key_;
  }
  if (key) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      key = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, key, submessage_arena);
    }
    set_has_key();
  } else {
    clear_has_key();
  }
  key_ = key;
  // @@protoc_insertion_point(field_set_allocated:fpm.AddRoute.key)
}

// optional .fpm.RouteType route_type = 5;
inline bool AddRoute::has_route_type() const {
  return (_has_bits_[0] & 0x00000010u) != 0;
}
inline void AddRoute::set_has_route_type() {
  _has_bits_[0] |= 0x00000010u;
}
inline void AddRoute::clear_has_route_type() {
  _has_bits_[0] &= ~0x00000010u;
}
inline void AddRoute::clear_route_type() {
  route_type_ = 0;
  clear_has_route_type();
}
inline ::fpm::RouteType AddRoute::route_type() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.route_type)
  return static_cast< ::fpm::RouteType >(route_type_);
}
inline void AddRoute::set_route_type(::fpm::RouteType value) {
  assert(::fpm::RouteType_IsValid(value));
  set_has_route_type();
  route_type_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.route_type)
}

// required .qpb.Protocol protocol = 6;
inline bool AddRoute::has_protocol() const {
  return (_has_bits_[0] & 0x00000020u) != 0;
}
inline void AddRoute::set_has_protocol() {
  _has_bits_[0] |= 0x00000020u;
}
inline void AddRoute::clear_has_protocol() {
  _has_bits_[0] &= ~0x00000020u;
}
inline void AddRoute::clear_protocol() {
  protocol_ = 0;
  clear_has_protocol();
}
inline ::qpb::Protocol AddRoute::protocol() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.protocol)
  return static_cast< ::qpb::Protocol >(protocol_);
}
inline void AddRoute::set_protocol(::qpb::Protocol value) {
  assert(::qpb::Protocol_IsValid(value));
  set_has_protocol();
  protocol_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.protocol)
}

// required int32 metric = 8;
inline bool AddRoute::has_metric() const {
  return (_has_bits_[0] & 0x00000040u) != 0;
}
inline void AddRoute::set_has_metric() {
  _has_bits_[0] |= 0x00000040u;
}
inline void AddRoute::clear_has_metric() {
  _has_bits_[0] &= ~0x00000040u;
}
inline void AddRoute::clear_metric() {
  metric_ = 0;
  clear_has_metric();
}
inline ::google::protobuf::int32 AddRoute::metric() const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.metric)
  return metric_;
}
inline void AddRoute::set_metric(::google::protobuf::int32 value) {
  set_has_metric();
  metric_ = value;
  // @@protoc_insertion_point(field_set:fpm.AddRoute.metric)
}

// repeated .fpm.Nexthop nexthops = 9;
inline int AddRoute::nexthops_size() const {
  return nexthops_.size();
}
inline void AddRoute::clear_nexthops() {
  nexthops_.Clear();
}
inline ::fpm::Nexthop* AddRoute::mutable_nexthops(int index) {
  // @@protoc_insertion_point(field_mutable:fpm.AddRoute.nexthops)
  return nexthops_.Mutable(index);
}
inline ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >*
AddRoute::mutable_nexthops() {
  // @@protoc_insertion_point(field_mutable_list:fpm.AddRoute.nexthops)
  return &nexthops_;
}
inline const ::fpm::Nexthop& AddRoute::nexthops(int index) const {
  // @@protoc_insertion_point(field_get:fpm.AddRoute.nexthops)
  return nexthops_.Get(index);
}
inline ::fpm::Nexthop* AddRoute::add_nexthops() {
  // @@protoc_insertion_point(field_add:fpm.AddRoute.nexthops)
  return nexthops_.Add();
}
inline const ::google::protobuf::RepeatedPtrField< ::fpm::Nexthop >&
AddRoute::nexthops() const {
  // @@protoc_insertion_point(field_list:fpm.AddRoute.nexthops)
  return nexthops_;
}

// -------------------------------------------------------------------

// Message

// optional .fpm.Message.Type type = 1;
inline bool Message::has_type() const {
  return (_has_bits_[0] & 0x00000004u) != 0;
}
inline void Message::set_has_type() {
  _has_bits_[0] |= 0x00000004u;
}
inline void Message::clear_has_type() {
  _has_bits_[0] &= ~0x00000004u;
}
inline void Message::clear_type() {
  type_ = 0;
  clear_has_type();
}
inline ::fpm::Message_Type Message::type() const {
  // @@protoc_insertion_point(field_get:fpm.Message.type)
  return static_cast< ::fpm::Message_Type >(type_);
}
inline void Message::set_type(::fpm::Message_Type value) {
  assert(::fpm::Message_Type_IsValid(value));
  set_has_type();
  type_ = value;
  // @@protoc_insertion_point(field_set:fpm.Message.type)
}

// optional .fpm.AddRoute add_route = 2;
inline bool Message::has_add_route() const {
  return (_has_bits_[0] & 0x00000001u) != 0;
}
inline void Message::set_has_add_route() {
  _has_bits_[0] |= 0x00000001u;
}
inline void Message::clear_has_add_route() {
  _has_bits_[0] &= ~0x00000001u;
}
inline void Message::clear_add_route() {
  if (add_route_ != NULL) add_route_->Clear();
  clear_has_add_route();
}
inline const ::fpm::AddRoute& Message::_internal_add_route() const {
  return *add_route_;
}
inline const ::fpm::AddRoute& Message::add_route() const {
  const ::fpm::AddRoute* p = add_route_;
  // @@protoc_insertion_point(field_get:fpm.Message.add_route)
  return p != NULL ? *p : *reinterpret_cast<const ::fpm::AddRoute*>(
      &::fpm::_AddRoute_default_instance_);
}
inline ::fpm::AddRoute* Message::release_add_route() {
  // @@protoc_insertion_point(field_release:fpm.Message.add_route)
  clear_has_add_route();
  ::fpm::AddRoute* temp = add_route_;
  add_route_ = NULL;
  return temp;
}
inline ::fpm::AddRoute* Message::mutable_add_route() {
  set_has_add_route();
  if (add_route_ == NULL) {
    auto* p = CreateMaybeMessage<::fpm::AddRoute>(GetArenaNoVirtual());
    add_route_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Message.add_route)
  return add_route_;
}
inline void Message::set_allocated_add_route(::fpm::AddRoute* add_route) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete add_route_;
  }
  if (add_route) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      add_route = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, add_route, submessage_arena);
    }
    set_has_add_route();
  } else {
    clear_has_add_route();
  }
  add_route_ = add_route;
  // @@protoc_insertion_point(field_set_allocated:fpm.Message.add_route)
}

// optional .fpm.DeleteRoute delete_route = 3;
inline bool Message::has_delete_route() const {
  return (_has_bits_[0] & 0x00000002u) != 0;
}
inline void Message::set_has_delete_route() {
  _has_bits_[0] |= 0x00000002u;
}
inline void Message::clear_has_delete_route() {
  _has_bits_[0] &= ~0x00000002u;
}
inline void Message::clear_delete_route() {
  if (delete_route_ != NULL) delete_route_->Clear();
  clear_has_delete_route();
}
inline const ::fpm::DeleteRoute& Message::_internal_delete_route() const {
  return *delete_route_;
}
inline const ::fpm::DeleteRoute& Message::delete_route() const {
  const ::fpm::DeleteRoute* p = delete_route_;
  // @@protoc_insertion_point(field_get:fpm.Message.delete_route)
  return p != NULL ? *p : *reinterpret_cast<const ::fpm::DeleteRoute*>(
      &::fpm::_DeleteRoute_default_instance_);
}
inline ::fpm::DeleteRoute* Message::release_delete_route() {
  // @@protoc_insertion_point(field_release:fpm.Message.delete_route)
  clear_has_delete_route();
  ::fpm::DeleteRoute* temp = delete_route_;
  delete_route_ = NULL;
  return temp;
}
inline ::fpm::DeleteRoute* Message::mutable_delete_route() {
  set_has_delete_route();
  if (delete_route_ == NULL) {
    auto* p = CreateMaybeMessage<::fpm::DeleteRoute>(GetArenaNoVirtual());
    delete_route_ = p;
  }
  // @@protoc_insertion_point(field_mutable:fpm.Message.delete_route)
  return delete_route_;
}
inline void Message::set_allocated_delete_route(::fpm::DeleteRoute* delete_route) {
  ::google::protobuf::Arena* message_arena = GetArenaNoVirtual();
  if (message_arena == NULL) {
    delete delete_route_;
  }
  if (delete_route) {
    ::google::protobuf::Arena* submessage_arena = NULL;
    if (message_arena != submessage_arena) {
      delete_route = ::google::protobuf::internal::GetOwnedMessage(
          message_arena, delete_route, submessage_arena);
    }
    set_has_delete_route();
  } else {
    clear_has_delete_route();
  }
  delete_route_ = delete_route;
  // @@protoc_insertion_point(field_set_allocated:fpm.Message.delete_route)
}

#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace fpm

namespace google {
namespace protobuf {

template <> struct is_proto_enum< ::fpm::Message_Type> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fpm::Message_Type>() {
  return ::fpm::Message_Type_descriptor();
}
template <> struct is_proto_enum< ::fpm::RouteType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::fpm::RouteType>() {
  return ::fpm::RouteType_descriptor();
}

}  // namespace protobuf
}  // namespace google

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_INCLUDED_fpm_2ffpm_2eproto
